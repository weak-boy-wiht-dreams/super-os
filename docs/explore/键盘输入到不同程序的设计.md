为所有键盘输入使用一个缓冲区: **key_buffer**, 而为指令使用单独的缓冲区**command_buffer**, 将它和键盘缓冲区分开。

key_buffer用于记录一定长度的输入历史，例如我按下了W, A, S, D, 左箭头, Enter, <键，则里面以一个队列的形式按顺序记录每个键:
...WASD"<-""Enter"<
这个key_buffer通过创建一个系统调用发送给其他程序:

**read()**: 用于获取整个key_buffer
**read(uint8_t length)**: 用于获取指定长度的字符串, 从最后一个进入队列向前数length个。

而原先的指令执行机制则在**按下回车时将队列中从上一个"Enter"开始到这个"Enter"中间的内容复制给command_buffer**,
目前打算暂行的方法如下:

设置一个bool位，用于表示现在正在执行指令还是其他程序: true=指令, false=其他程序

1. 每输入一个键，加入key_buffer中;
2. 当按下Enter时, 先将Enter加入key_buffer中，如果正在执行指令, 则将从上一个"Enter"(之前有指令)或字符串开头到这个"Enter"之间的内容复制给command_buffer, 进入3, 否则进入4;
3. 按照原先逻辑执行指令
4. 此时正在执行其他程序, 则不做任何处理(其他程序自行获取key_buffer)

另外，为了使得逻辑完备，从其他程序中退出时，自动在key_buffer最后添加一个"Enter"，这样做是为了防止影响key_buffer队列，考虑以下情况：

| 情况  | key_buffer内容(...表示之前的输入)  |
| - | - |
| 1. 我们按"q"键从贪吃蛇中退出了。| ... | 
| 2. "q"键通过中断服务程序写入key_buffer中。 | ...q |
| 3. 我们接着输入下一个指令: DIR | ...qDIR |
| 4. 按下回车执行 | ...qDIR"Enter" |

此时就会出现将之前的所有输入都读取到command_buffer中的情况。因此，结束一个程序可以有两种方法来解决这个问题：

1. 使用"Enter"作为程序的退出键。这样做写死了按键，我们并不知道用户会用什么键位来退出程序，因此不合理。
2. 在一个程序结束时，向key_buffer中自动添加一个"Enter"。这样做更加合理，既统一了检测用的按键，也不假设用户用什么按键退出自己的程序。


### 2024/1/7
目前，为了渐进的兼容性，暂时不修改现在读入key_buffer的逻辑，添加一个临时的"keychain_buffer"作为输入队列的保存地点，
并在贪吃蛇中使用keychain_buffer读入。


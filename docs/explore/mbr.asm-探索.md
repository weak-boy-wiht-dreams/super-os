```asm
[org 0x7c00]
```

这个咱们不用多说，是BIOS加载MBR到的目标内存位置。我们只需要注意下面两点：

1. 这个地址不是我们指定的，是一个约定俗称的值。换句话说，我们指定这个值，是为了符合规范，而不是制定规范; 因为规定的代码起始地址是这个地址，bootloader会被自动加载到这个地址，我们为了后面的代码能够正常跳转，也只能指定这个起始的值。这个值是给我们的代码用的，而不是给BIOS用的。
2. 这个指令本质的意义是：之后所有的地址跳转都是基于这个值的偏移。

关于这个值的来源，最早可以追溯到IBM PC时代的规范。

什么时候使用这个值?

- 加载bootloader代码时
- 需要确保地址跳转的地址和bootloader对齐的时候(已经启动后因为某些情况脱离了这个基址，需要回来)(不过啥时候会有这种情况鹅鹅鹅)

```asm
KERNEL_OFFSET 0x1000
```

这个是我们加载内核代码的地址，可以修改，不过需要和扇区对齐(是512的整数倍)。<s>作死</s>具体表现：
* 当修改成和扇区不对齐的地址时(例如0x1001), 会导致所有指令错位甚至无法解析, 因为指令都是从某个扇区的开头开始保存的。

* 当只修改这个值而不修改链接器的值时，会导致实际地址和指定地址错位，无法读取。

下面是内存的整体安排:

```

内存地址
0x0000  +------------------+
        |  BIOS数据区       |
        |                  |
0x1000  +------------------+
        |  内核代码          |  <-- KERNEL_OFFSET
        |  (较大空间)        |
        |                  |
        |                  |
0x7C00  +------------------+
        |  引导程序(MBR)     |  <-- 512字节
        |                  |
0x7E00  +------------------+
0x9000  |  栈空间           |  <-- 程序中设置的栈位置
        |                  |
        +------------------+

```

```asm
mov [BOOT_DRIVE], dl
mov bp, 0x9000 ; 设置栈基地址为0x9000
mov sp, bp ; 设置栈指针为bp
```
这段代码的作用是初始化栈指针(这个是调用栈那个栈吗? gpt答曰: 是), 万物之源的级别。之后的一层层函数调用都是将地址存入这个栈中的。
缩写的含义:

sp: **s**tack **p**ointer: 栈指针
bp: **b**ase **p**ointer: 基指针

就像我们计算一个字符串长度需要一个开头指针和一个遍历指针一样，一个起点和一个游客决定了整个景区的而地图。

dl暂时意义不明。

注: 栈指针是从大地址到小地址的

中间的打印信息部分略过，本质上是遍历位于一个地址段的字符，一个一个调用cpu中断进行屏幕输出

```asm
; 加载内核到内存
call load_kernel
; 切换到32位保护模式
call switch_to_32bit
; 无限循环，防止意外执行
jmp $ ; 此代码不会执行到这里
```

上面这段我们开始加载内核代码了，接下来这段就是真正的从磁盘读取的逻辑：
1. 先将寄存器bx指向KERNEL_OFFSET(在这里我们使用的0x1000)
2. 将dx寄存器的高地址部分dh指向31(用于存储一个立即数31, 表示我们内核的扇区数)
3. 将dl指向BOOT_DRIVE保存的驱动器号这个立即数
4. 调用disk_load进行加载

```asm
    mov bx, KERNEL_OFFSET ; 内核加载地址
    mov dh, 31            ; 假定内核大小为31个扇区
    mov dl, [BOOT_DRIVE]  ; 使用保存的引导驱动器号
    call disk_load        ; 调用磁盘加载函数
    ret                   ; 返回
```




另：发现一个事情: 每次修改了地址什么的，需要执行make clean后再重新make, 不然不能生效
+ 可能是和编译出的kernel.bin, kernel.elf相关的东西修改后都需要先make clean再make